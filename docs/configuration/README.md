---
sidebarDepth: 3
---

# Configuration

The behaviour of this package is highly customizable.
You can define which components should be generated by the `php artisan make:module` command, what kind of routing is preferred and how the module should be structured. The routing, the structure and a status is also configurable for every module individually.  
To be able to do the mentioned settings there must be either a `config/modules.php` file or a `config.php` inside a module.

<br>
<br>

## Publish the Config File

You can get the config file by executing the following command in a bash prompt from your projects root

```bash
php artisan vendor:publish
```

You will most likely be asked to decide what to publish.

```text
Which provider or tag's files would you like to publish?:
  [0] Publish files from all providers and tags listed below
  [1] Provider: ArtemSchander\L5Modular\ModuleServiceProvider
```

Pick either `0` to publish everything or at least the number with `Provider: ArtemSchander\L5Modular\ModuleServiceProvider`.  
When this is done, you can configure in the published `config/modules.php` file the following...

<br>
<br>

## Module Generation

#### `config('modules.generate')`

By default the generation of some components is disabled.  
The `generate` array accepts boolean values to enable / disable the generation of a component.

```php
'generate' => [
    'controller' => true,
    'resource' => false,
    'request' => false,
    'model' => true,
    'mail' => false,
    'notification' => false,
    'event' => false,
    'listener' => false,
    'observer' => false,
    'job' => false,
    'rule' => false,
    'view' => true,
    'translation' => true,
    'routes' => true,
    'migration' => false,
    'seeder' => false,
    'factory' => false,
    'config' => false,
    'helpers' => false,
],
```
<br>
<br>

## Default Module

#### `config('modules.default')`

Everything you configure here, will be applied to all modules unless they have their own settings defined under `specific` or in a separate `config.php` file.  
The default settings consists of `routing` and `structure`.

```php
'default' => [

    /*
    |--------------------------------------------------------------------------
    | Type Of Routing
    |--------------------------------------------------------------------------
    |
    | If you need / don't need different route files for web and api
    | you can change the array entries like you need them.
    |
    | Supported: "web", "api", "simple"
    |
    */

    'routing' => [ 'web', 'api' ],

    /*
    |--------------------------------------------------------------------------
    | Module Structure
    |--------------------------------------------------------------------------
    |
    | In case your desired module structure differs
    | from the default structure defined here
    | feel free to change it the way you like it,
    |
    */

    'structure' => [
        'controllers' => 'Http/Controllers',
        'resources' => 'Http/Resources',
        'requests' => 'Http/Requests',
        'models' => 'Models',
        'mails' => 'Mail',
        'notifications' => 'Notifications',
        'events' => 'Events',
        'listeners' => 'Listeners',
        'observers' => 'Observers',
        'jobs' => 'Jobs',
        'rules' => 'Rules',
        'views' => 'resources/views',
        'translations' => 'resources/lang',
        'routes' => 'routes',
        'migrations' => 'database/migrations',
        'seeds' => 'database/seeds',
        'factories' => 'database/factories',
        'helpers' => '',
    ],
],
```

<br>

#### `config('modules.default.routing')`

Here you can define which type of route files will be generated and loaded. The possible options are: `web` `api` `simple`

```php
'routing' => [ 'web', 'api' ],
```

1. **web**  
The make command will generate a `web.php` file with a predefined resource route.  
The service provider will load the file if it exists, apply the "web" middleware and the "controllers" namespace of the corresponding module.
2. **api**  
The make command will generate an empty `api.php` file.  
The service provider will load the file if it exists, apply the "api" middleware and the "controllers" namespace of the corresponding module.
3. **simple**  
The make command will generate a `routes.php` file with a predefined resource route.  
The service provider will load the file if it exists and apply the "controllers" namespace of the corresponding module.

<br>

#### `config('modules.default.structure')`

The structure config accepts an associative array, while the values represent the path to the component stated in the key.

```php
'structure' => [
    'controllers' => 'Http/Controllers',
    'resources' => 'Http/Resources',
    'requests' => 'Http/Requests',
    'models' => 'Models',
    'mails' => 'Mail',
    'notifications' => 'Notifications',
    'events' => 'Events',
    'listeners' => 'Listeners',
    'observers' => 'Observers',
    'jobs' => 'Jobs',
    'rules' => 'Rules',
    'views' => 'resources/views',
    'translations' => 'resources/lang',
    'routes' => 'routes',
    'migrations' => 'database/migrations',
    'seeds' => 'database/seeds',
    'factories' => 'database/factories',
    'helpers' => '',
],
```

If the value is an empty string, the component will be generated right into the module folder and expected there by the service provider.

<br>
<br>

## Specific Module

#### `config('modules.specific')`

Every exception to the default config should be defined here or in a separete `config.php` in the root of any module.  
It is important to name the keys exactly like the modules the containing config should affect.

```php
'specific' => [

    /*
    |--------------------------------------------------------------------------
    | Example Module
    |--------------------------------------------------------------------------
    |
    | This type of configuration would you allow
    | to use modules from L5Modular v1
    |
    | 'ExampleModule' => [
    |     'enabled' => false,
    |     'routing' => [ 'simple' ],
    |     'structure' => [
    |         'controllers' => 'Controllers',
    |         'views' => 'Views',
    |         'translations' => 'Translations',
    |     ],
    | ],
    */

],
```

In every module specific config you can configure the `routing` and the `structure` the same way as it is possible for the default config.  
Besides that, this is the right place to disable modules.

<br>

### Disable a module

To disable a module you need to set the `enabled` setting to `false`.  
The config to disable the HelloWorld module would then look like this

```php
return [
    // ...
    'specific' => [
        'HelloWorld' => [
            'enabled' => false,
        ],
    ]
];
```

<br>

### Change the routing

To change the routing to load only a simple `routes.php` for the HelloWorld module you would need this config

```php
return [
    // ...
    'specific' => [
        'HelloWorld' => [
            'routing' => [ 'simple' ],
        ],
    ]
];
```

<br>

### Change the structure

You can completely customize the structure of each module.

```php
return [
    // ...
    'specific' => [
        'HelloWorld' => [
            'routing' => [ 'simple' ],
            'structure' => [
                'controllers' => 'Controllers',
                'resources' => 'Resources',
                'requests' => 'Requests',
                'models' => 'Entities',
                'views' => 'Views',
                'translations' => 'Translations',
                'routes' => '',
                'migrations' => 'database/migrations',
                'seeds' => 'database/seeds',
                'factories' => 'database/factories',
                'helpers' => '',
            ],
        ],
    ]
];
```

With this config the service provider would expect the following structure and load all existing files while ignoring the nonexistent ones

```bash
laravel-project/
    app/
    └── Modules/
        └── HelloWorld/
            ├── Controllers
            │   └── HelloWorldController.php
            ├── Entities
            │   └── HelloWorld.php
            ├── Resources
            │   └── HelloWorldResource.php
            ├── Requests
            │   └── HelloWorldRequest.php
            ├── Translations
            │   └── en.php
            ├── Views
            │   └── index.blade.php
            ├── database
            │   ├── factories
            │   │   └── HelloWorldFactory.php
            │   ├── migrations
            │   │   └── xxx_create_foo_bars_table.php
            │   └── seeds
            │       └── HelloWorldSeeder.php
            ├── helpers.php
            └── routes.php
```

<br>
<br>

## Separate Config File In A Module

Any config from `specific` can also be applied by creating a `config.php` into the root of a module.  
A valid example would be `app/Modules/HelloWorld/config.php`

```php
return = [
    'enabled' => false,
    'routing' => [ 'simple' ],
    'structure' => [
        'controllers' => 'Controllers',
        'views' => 'Views',
        'translations' => 'Translations',
    ],
];
```

**Note:** This kind of config has less priority than the `specific` part from `config/modules.php`  
If both variants exist, they will be merged in favor of `config/modules.php`.

<br>
<br>

## Custom Configurations

In addition to the settings used by this package you can put any type of config into both, the `specific` and the separate `config.php`.
The merged config will always be accessible in two ways `config('modules.specific.HelloWorld')` and/or `config('HelloWorld')`.

Example: `app/Modules/HelloWorld/config.php`

```php
return = [
    'enabled' => true,
    'custom' => 1337,
];
```

In this case the value of `custom` could be accessed by `config('modules.specific.HelloWorld.custom')` or simply by `config('HelloWorld.custom')`.
